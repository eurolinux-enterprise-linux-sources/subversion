
https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-1968

http://svn.apache.org/viewvc?view=revision&revision=1485299

plus backport of SVN_TEST_ASSERT() macro from 1.7.x

--- subversion-1.6.11/subversion/libsvn_fs_fs/tree.c.cve1968
+++ subversion-1.6.11/subversion/libsvn_fs_fs/tree.c
@@ -43,6 +43,7 @@
 #include "svn_mergeinfo.h"
 #include "svn_fs.h"
 #include "svn_props.h"
+#include "svn_ctype.h"
 
 #include "fs.h"
 #include "err.h"
@@ -1837,6 +1838,78 @@ fs_dir_entries(apr_hash_t **table_p,
   return svn_fs_fs__dag_dir_entries(table_p, node, pool, pool);
 }
 
+/* Return a copy of PATH, allocated from POOL, for which control
+   characters have been escaped using the form \NNN (where NNN is the
+   octal representation of the byte's ordinal value).  */
+static const char *
+illegal_path_escape(const char *path, apr_pool_t *pool)
+{
+  svn_stringbuf_t *retstr;
+  apr_size_t i, copied = 0;
+  int c;
+
+  /* At least one control character:
+      strlen - 1 (control) + \ + N + N + N + null . */
+  retstr = svn_stringbuf_create_ensure(strlen(path) + 4, pool);
+  for (i = 0; path[i]; i++)
+    {
+      c = (unsigned char)path[i];
+      if (! svn_ctype_iscntrl(c))
+        continue;
+
+      /* If we got here, we're looking at a character that isn't
+         supported by the (or at least, our) URI encoding scheme.  We
+         need to escape this character.  */
+
+      /* First things first, copy all the good stuff that we haven't
+         yet copied into our output buffer. */
+      if (i - copied)
+        svn_stringbuf_appendbytes(retstr, path + copied,
+                                  i - copied);
+
+      /* Make sure buffer is big enough for '\' 'N' 'N' 'N' (and NUL) */
+      svn_stringbuf_ensure(retstr, retstr->len + 5);
+      /*### The backslash separator doesn't work too great with Windows,
+         but it's what we'll use for consistency with invalid utf8
+         formatting (until someone has a better idea) */
+      apr_snprintf(retstr->data + retstr->len, 5, "\\%03o", (unsigned char)c);
+      retstr->len += 4;
+
+      /* Finally, update our copy counter. */
+      copied = i + 1;
+    }
+
+  /* If we didn't encode anything, we don't need to duplicate the string. */
+  if (retstr->len == 0)
+    return path;
+
+  /* Anything left to copy? */
+  if (i - copied)
+    svn_stringbuf_appendbytes(retstr, path + copied, i - copied);
+
+  /* retstr is null-terminated either by apr_snprintf or the svn_stringbuf
+     functions. */
+
+  return retstr->data;
+}
+
+/* Raise an error if PATH contains a newline because FSFS cannot handle
+ * such paths. See issue #4340. */
+static svn_error_t *
+check_newline(const char *path, apr_pool_t *pool)
+{
+  const char *c;
+
+  for (c = path; *c; c++)
+    {
+      if (*c == '\n')
+        return svn_error_createf(SVN_ERR_FS_PATH_SYNTAX, NULL,
+           _("Invalid control character '0x%02x' in path '%s'"),
+           (unsigned char)*c, illegal_path_escape(path, pool));
+    }
+
+  return SVN_NO_ERROR;
+}
 
 /* Create a new directory named PATH in ROOT.  The new directory has
    no entries, and no properties.  ROOT must be the root of a
@@ -1851,6 +1924,8 @@ fs_make_dir(svn_fs_root_t *root,
   dag_node_t *sub_dir;
   const char *txn_id = root->txn;
 
+  SVN_ERR(check_newline(path, pool));
+
   SVN_ERR(open_path(&parent_path, root, path, open_path_last_optional,
                     txn_id, pool));
 
@@ -2113,6 +2188,8 @@ fs_copy(svn_fs_root_t *from_root,
         const char *to_path,
         apr_pool_t *pool)
 {
+  SVN_ERR(check_newline(to_path, pool));
+
   return copy_helper(from_root, from_path, to_root, to_path, TRUE, pool);
 }
 
@@ -2203,6 +2280,8 @@ fs_make_file(svn_fs_root_t *root,
   dag_node_t *child;
   const char *txn_id = root->txn;
 
+  SVN_ERR(check_newline(path, pool));
+
   SVN_ERR(open_path(&parent_path, root, path, open_path_last_optional,
                     txn_id, pool));
 
--- subversion-1.6.11/subversion/tests/libsvn_fs/fs-test.c.cve1968
+++ subversion-1.6.11/subversion/tests/libsvn_fs/fs-test.c
@@ -4927,6 +4927,81 @@ node_origin_rev(const char **msg,
   return SVN_NO_ERROR;
 }
 
+/** Handy macro to test a condition, returning SVN_ERR_TEST_FAILED if FALSE
+ *
+ * This macro should be used in place of SVN_ERR_ASSERT() since we don't
+ * want to core-dump the test.
+ */
+#define SVN_TEST_ASSERT(expr)                                     \
+  do {                                                            \
+    if (!(expr))                                                  \
+      return svn_error_createf(SVN_ERR_TEST_FAILED, NULL,         \
+                               "assertion '%s' failed at %s:%d",  \
+                               #expr, __FILE__, __LINE__);        \
+  } while (0)
+
+/* Issue 4340, "fs layer should reject filenames with trailing \n" */
+static svn_error_t *
+filename_trailing_newline(const char **msg,
+                          svn_boolean_t msg_only,
+                          svn_test_opts_t *opts,
+                          apr_pool_t *pool)
+{
+  apr_pool_t *subpool = svn_pool_create(pool);
+  svn_fs_t *fs;
+  svn_fs_txn_t *txn;
+  svn_fs_root_t *txn_root, *root;
+  svn_revnum_t youngest_rev = 0;
+  svn_error_t *err;
+  svn_boolean_t allow_newlines;
+  
+  /* Some filesystem implementations can handle newlines in filenames
+   * and can be white-listed here.
+   * Currently, only BDB supports \n in filenames. */
+  allow_newlines = (strcmp(opts->fs_type, "bdb") == 0);
+
+  *msg = "filenames with trailing \\n might be rejected";
+  if (msg_only)
+    return SVN_NO_ERROR;
+
+  SVN_ERR(svn_test__create_fs(&fs, "test-filename-trailing-newline",
+                              opts, pool));
+
+  /* Revision 1:  Add a directory /foo  */
+  SVN_ERR(svn_fs_begin_txn(&txn, fs, youngest_rev, subpool));
+  SVN_ERR(svn_fs_txn_root(&txn_root, txn, subpool));
+  SVN_ERR(svn_fs_make_dir(txn_root, "/foo", subpool));
+  SVN_ERR(svn_fs_commit_txn(NULL, &youngest_rev, txn, subpool));
+  SVN_TEST_ASSERT(SVN_IS_VALID_REVNUM(youngest_rev));
+  svn_pool_clear(subpool);
+
+  /* Attempt to copy /foo to "/bar\n". This should fail on FSFS. */
+  SVN_ERR(svn_fs_begin_txn(&txn, fs, youngest_rev, subpool));
+  SVN_ERR(svn_fs_txn_root(&txn_root, txn, subpool));
+  SVN_ERR(svn_fs_revision_root(&root, fs, youngest_rev, subpool));
+  err = svn_fs_copy(root, "/foo", txn_root, "/bar\n", subpool);
+  if (allow_newlines)
+    SVN_TEST_ASSERT(err == SVN_NO_ERROR);
+  else
+    {
+      SVN_TEST_ASSERT(err && err->apr_err ==  SVN_ERR_FS_PATH_SYNTAX);
+      svn_error_clear(err);
+    }
+
+  /* Attempt to create a file /foo/baz\n. This should fail on FSFS. */
+  err = svn_fs_make_file(txn_root, "/foo/baz\n", subpool);
+  if (allow_newlines)
+    SVN_TEST_ASSERT(err == SVN_NO_ERROR);
+  else
+    {
+      SVN_TEST_ASSERT(err && err->apr_err ==  SVN_ERR_FS_PATH_SYNTAX);
+      svn_error_clear(err);
+    }
+
+  return SVN_NO_ERROR;
+}
+
+
 /* ------------------------------------------------------------------------ */
 
 /* The test table.  */
@@ -4970,5 +5045,6 @@ struct svn_test_descriptor_t test_funcs[
     SVN_TEST_PASS(set_uuid),
     SVN_TEST_PASS(node_origin_rev),
     SVN_TEST_PASS(small_file_integrity),
+    SVN_TEST_PASS(filename_trailing_newline),
     SVN_TEST_NULL
   };
